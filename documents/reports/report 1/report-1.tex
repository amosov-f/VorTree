\documentclass{article}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
%\usepackage{graphics}
%\usepackage{amsfonts}
%\usepackage{savesym}
%\savesymbol{iint}
%\restoresymbol{TXF}{iint}


\hoffset -2.0cm
\voffset -3.0cm
\textheight 23.5cm
\textwidth 17.0cm

\title{\bf Отчет \No 1}
\author{Амосов Федор}

\begin{document}
    \maketitle
    
    \section{Постановка задачи}
        Пусть задано метрическое пространство $(\mathbb{R}^m, d)$. Дан набор точек $P = \{p_i\}_{i = 1}^n$ из $\mathbb{R}^m$. Требуется построить структуру на $P$, которая позволит эффективно отвечать на следующие запросы:
        \begin{itemize}
            \item Найти ближайшую точку из $P$ к данной точке $q$ (NN),
            \item Найти $k$ ближайших точек из $P$ к данной точке $q$ (kNN),
        \end{itemize}
        
        {\bf Вопрос 1.} Я прав, что под эффективностью мы будем подразумевать не алгоритмическую сложность, меньшую, чем $\Theta(n)$, а хорошее время работы на реальных датасетах?
    
    \section{Структуры данных}
        \subsection{M--tree}
            Это абстрактная структура данных. Она представляет собой дерево поиска, листьями которого являются точки из $P$, а остальными вершинами ---  шары в $\mathbb{R}^m$. Такие вершины содержат ссылки либо на поддеревья, либо на листья. Все шары в поддереве должны содержаться в шаре корня этого поддерева. Если вершина ссылается на лист, то соответсвующая точка должна содержатся в шаре этой вершины.
            \subsubsection{Построение}
                Алгоритм построения на точках $P$ выглядит следующим образом.
                \begin{itemize}
                    \item Разбиваем $P$ на части, соответсвующие ближайшим соседям некоторых точек из $P$,
                    \item В каждой части строим $M$--дерево,
                    \item Собираем полученные деревья в одно дерево, устанавливая над ними корневую вершину.
                \end{itemize}           
                                     
                {\bf Замечание 1.} Построение надо как--то аккуратно делать, чтобы покрыть шарами <<все точки>>.                
                
                {\bf Замечание 2.} Корневой вершине можно дать шар с цетром в цетроиде $P$ и радиусом, покрывающим $P$.
                
                {\bf Замечание 3.} Базой этого рекурсивного алгоритма можно считать следующее. Если размер $P$ достаточно мал, то можно закончить текущее построение, сделав листьями точки $P$.
               
                {\bf Вопрос 2.} Как тут дела со сбалансированностью? В статье написано пару строк на эту тему, но как--то непонятно. Там говорят, что для балансировки нужно проводить еще операции (split и т.п.). Я не совсем понимаю, к чему приведут эти операции.                
                
                {\bf Вопрос 3.} Стоит ли нам задумываться об онлайн--построении структур? Т.е. стоит ли разбирать операции insert и т.п.?
                
            \subsubsection{Запрос}
                Разберем запрос NN. 
                
                {\bf Вопрос 4.} Как нормально делать запрос в таком дереве? В статье я что--то не вижу. На Википедии этого тоже нет.
                Мой вариант нахождения соседа точки $q$: 
                \begin{itemize}
                    \item Если потомки текущей вершины являются точками из $P$, то находим среди них самую близкую к $q$ и возвращаем ее.
                    \item Иначе, находим все шары, соответствующие потомкам текущей вершины, в которых есть точка $q$. Если таких нет, то прекращаем работу.  
                    \item Делаем NN запрос в каждое поддерево. Получаем набор точек--кандидатов. Среди них выбираем лучшую и возвращаем.
                \end{itemize}     
                
                {\bf Вопрос 5.} Что делать, если запрос $q$ находится далеко--далеко от множества $P$ и не покрывается ни одним шаром?
                
                {\bf Вопрос 6.} Как тут дела обстоят с аналитическими оценками на время работы? Это касается и построения тоже.
                
        \subsection{R--tree}
            {\bf Вопрос 7.} Правда, что R--tree --- это реализация абстрактной структуры M---tree, при построении использующая метрику $L_\infty$?
            
        \subsection{VoR--tree}
            Это R--tree, в котором в каждом листе, помимо самих точек из $P$, хранится еще и информация об их ячейках Вороного. Опишем, как это может ускорить процесс поиска. Рассмотрим NN запрос для точки $q$.
            
            Поиск мы проводим с помощью BFS в R--tree. В BFS мы используем очередь с приоритетами из вершин дерева. В качестве приоритетов мы используем расстояние от точки $q$ до прямоугольника, соответствующего вершине дерева. На этапе обработки листьев, мы пытаемся найти ту вершину из листа, в чьей ячейке Вороного находится $q$.
            
            Для запроса kNN используется BFS на графе Делоне от NN вершины. Там все просто.            
            
            {\bf Вопрос 8.} Зачем хранить информацию в листьях R--дерева о соседях точек из $P$ в графе Делоне (см. рисунок 2 в соответствующей статье)? Мы используем граф Делоне, но не в самом R--tree (см. kNN)
            
    \section{Видимые мной задачи}
        \begin{itemize}
            \item Создать проект. Написать интерфейс структуры, решающей нашу задачу (NN и kNN). Сделать простейшую(наивную) реализацию.
            \item Найти интересный датасет. Сделать тесты с помощью наивной реализации.
            \item Написать R--tree как реализацию интерфейса. Сравнить эффективность наивной реализации и R--tree.
            \item Написать быстрое построение диаграммы Вороного. Подойдет, к примеру, алгоритм Форчуна.
            \item Улучшить R--tree до VoR--tree. Сравнить эффективность R--tree и VoR--tree.
            \item {\bf Придумать}, как распаралелить построение VoR--tree, используя интерфейс MapReduce.
            \item Реализовать распараллеливание, используя Hadoop.
            \item Научиться строить SQL индекс по VoR--tree.
            \item Написать фреймворк, реализующий весь pipeline. На вход -- набор точек, на выход -- SQL индекс.
            \item Добавить в фреймворк другие алгоритмы для анализа сравнительной эффективности.
        \end{itemize}            

\end{document}