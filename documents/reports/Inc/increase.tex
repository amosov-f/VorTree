\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphics}
\usepackage{amsfonts}
\usepackage{amssymb}

\ifx\pdfoutput\undefined
\usepackage{graphicx}
\else
\usepackage[pdftex]{graphicx}
\fi

\hoffset -2.0cm	
\voffset -3.0cm
\textheight 23.5cm 
\textwidth 17.0cm

\title{\bf Ускорение алгоритмов построения триангуляции Делоне/диаграммы Вороного}
\author{Амосов Федор}

\begin{document}
	\maketitle
	
	Итак, вспомним наш алгоритм построения графа Делоне $D$ на наборе точек $P$ через склеивание меньших подграфов.
    \begin{enumerate}
        \item Пусть $S_i$ --- случайный поднабор точек из $P$ размера $m$;
        \item Пусть $P_i$ --- разбиение точек $P$ по клеткам Вороного $C_i$ набора точек $S_i$ (каждое $P_i$ --- это множество точек);
        \item Построим граф Делоне $D_i$ на каждом множестве $P_i$ рекурсивным вызовом этого алгоритма. Пусть наш алгоритм возвращает помимо построенного графа еще и точки границы выпуклой оболочки. Тем самым, мы получим еще и $H_i$ --- точки границы выпуклой оболочки $D_i$ ($P_i$);
        \item Найдем все граничные треугольники. Мы их легко получим, зная все граничные точки $H_i$. Запустим dfs, описанный в предыдущем отчете, на графе соседних треугольников. С помощью него мы найдем все <<плохие>> треугольники. Выбросим все плохие треугольники из $D_i$;
        \item Сконструируем множество точек $V$. Добавим в него все множества $H_i$. Так же добавим в него все точки найденных плохих треугольников;
        \item Построим $G$ --- граф Делоне на $V$. Сделаем мы это каким--нибудь {\bf другим} построителем графов Делоне;
        \item Найдем в $G$ те ребра, которые связывают вершины разных $D_i$;
        \item Получим итоговый граф Делоне $D$ вставкой этих ребер в объединение $D_i$.
    \end{enumerate}    
    
    На сей момент, корректность этого алгоритма была <<проверена>> только многочисленными экспериментами. Но сейчас нам будет интересен другой вопрос. Сколько этот алгоритм работает (в количестве операций)?
    
    Итак, пусть $T(n)$ --- время работы этого алгоритма на наборе из $n$ точек. Пусть двумерных. Составим рекуррентное соотношение на $T(n)$. Предположения, в которых мы будем это делать,
    \begin{itemize}
        \item Все $Conv P_i$ имеют высокую выпуклость (не выстраиваются в линии)
        \item Все $P_i$ имеют похожие размеры
    \end{itemize}    	
    Добиться этого можно взяв $m$ (число множеств $P_i$) достаточно большим. Будем считать $m$ константой.
    
    Итак, из чего складывается $T(n)$,
    \begin{enumerate}
        \item Выбор $m$ случайных точек --- $O(m) = O(1)$
        \item Разбиение всех точек по $m$ клеткам. С учетом того, что $m$ --- константа, мы можем это сделать за $O(n f(m)) = O(n)$, где $f(m)$ --- некоторая малая функция типа $\log m$ и т.п.
        \item Построение всех $D_i$ --- $m T(\frac{n}{m})$
        \item Запуск всех dfs --- $O(m g(\frac{n}{m}) \log n)$, где $g(n)$ --- ориентировочное число точек границы выпуклой оболочки случайного множества из $n$ точек. Для двумерного случая $g(n) = O(\sqrt{n})$. $\log n$ вылезает из--за поиска точки в круге при проверке треугольника на <<хорошесть>>. Н.У.О. у нас уже построен поисковый индекс на $P$ (или его частях). Тем самым, сложность получается такой, $O(n^{\frac{1}{2}} \log n)$.
        \item Конструирование $V$ --- $O(m n^{\frac{1}{2}}) = O(n^{\frac{1}{2}})$, т.к. все плохие треугольники будут вдоль границ.
        \item Пусть внешний алгоритм построения графа Делоне работает за $O(n^k)$. Тогда мы получим время работы на этом этапе $O((n^{\frac{1}{2}})^k) = O(n^\frac{k}{2})$.  
        \item Нахождение нужных ребер --- $O(n^\frac{1}{2})$
        \item Вставка ребер (удаление уже было произведено на этапе нахождения плохих треугольников) --- $O(n^\frac{1}{2})$
    \end{enumerate}
    
    Итого, 
    $$
        T(n) \le O(1) + O(n) + m T\left( \frac{n}{m}  \right) + O(n^\frac{1}{2} \log n) + O(n^{\frac{1}{2}}) + O(n^\frac{k}{2}) + O(n^\frac{1}{2}) + O(n^\frac{1}{2})
    $$    
    $$
        T(n) \le m T \left( \frac{n}{m} \right) + O(n) + O(n^\frac{k}{2})
    $$
    $$
        T(n) \le \left\{
            	\begin{array}{c}
				m T \left( \frac{n}{m} \right) + O(n), ~~~ k \le 2	\\
				m T \left( \frac{n}{m} \right) + O(n^\frac{k}{2}), ~~~ k > 2
			\end{array}
		\right.		
	$$
	
	Вспомним основную теорему о рекуррентном соотношении.
	
	\paragraph{Теорема\\}
	    Если 
	    $$
	        T(n) \le a T \left( \frac{n}{b} \right) + O(n^d)
	    $$
	    То
	    $$
	        T(n) = \left\{
            	    \begin{array}{c}
				    O(n^d), ~~~ d > \log_b a    \\
				    O(n^d \log n), ~~~ d = \log_b a    \\
				    O(n^{\log_b a}), ~~~ d < \log_b a
			    \end{array}
		    \right.		
	    $$
	    
	Воспользуемся ей для нашего случая. Итого получается, 
	$$
	    T(n) \le \left\{
            	\begin{array}{c}
				O(n \log n), ~~~ k \le 2	\\
				O(n^\frac{k}{2}), ~~~ k > 2
			\end{array}
		\right.	
    $$
    
    Тем самым, что мы сделали. Пусть у нас есть <<тормознутый>> алгоритм построения триангуляции Делоне. В нем много вычей, всяких непонятных штук и т.п. и он работает за $O(n^k)$. Мы научились <<за дешево>> его асимптотически ускорять по следующей схеме,
    $$
        O(n^k) \rightarrow O(n \log n), ~~~ k \le 2
    $$
    $$
        O(n^k) \rightarrow O(n^\frac{k}{2}), ~~~ k > 2
    $$
    
    Более того, мы видим что этот переход сделан <<с запасом>>, т.к. многие <<хлипкие>> $O(n^\frac{1}{2})$ были съедены ясной и понятной $O(n)$. 
    
    Тем самым, мы тупейший алгоритм $O(n^4)$ научились задаром превращать в $O(n^2)$, а какие--нибудь медленные, но надежные алгоритмы $O(n^2)$ сразу в $O(n \log n)$. Можем пойти еще дальше. Берем тупейший алгоритм $O(n^4)$, ускоряем его до $O(n^2)$, затем этот ускоренный алгоритм ускоряем до $O(n \log n)$. Как то странно это все, но весело =) Более того, это добро с виду хорошо параллелится. Еще можно подумать над тем, что строить граф Делоне $G$ можно тоже без всяких внешних алгоритмов, а просто рекурсивным запуском нашего. Там тогда сразу получится сложность $O(n \log n)$, но это мутный момент, потому что становится непонятно, где мы вообще в таком случае что--то строим.
    
     Осталось доказать два Утверждения для доказательства корректности алгоритма --- и дело будет в шляпе =)
	
	
	
\end{document}
	
    	
	
\end{document}